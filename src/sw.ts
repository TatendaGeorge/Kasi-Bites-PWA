/// <reference lib="webworker" />
import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching'
import { registerRoute } from 'workbox-routing'
import { StaleWhileRevalidate, NetworkFirst, CacheFirst } from 'workbox-strategies'
import { ExpirationPlugin } from 'workbox-expiration'

declare let self: ServiceWorkerGlobalScope

// Precache all assets generated by the build process
precacheAndRoute(self.__WB_MANIFEST)

// Clean up old caches
cleanupOutdatedCaches()

// Runtime caching for API calls
registerRoute(
  ({ url }) => url.pathname === '/api/products',
  new StaleWhileRevalidate({
    cacheName: 'products-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24, // 24 hours
      }),
    ],
  })
)

registerRoute(
  ({ url }) => url.pathname.startsWith('/api/orders'),
  new NetworkFirst({
    cacheName: 'orders-cache',
    networkTimeoutSeconds: 10,
  })
)

registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  })
)

// Push notification event handler
self.addEventListener('push', (event) => {
  if (!event.data) {
    return
  }

  try {
    const payload = event.data.json()

    const options = {
      body: payload.body,
      icon: payload.icon || '/icons/icon-192x192.svg',
      badge: payload.badge || '/icons/icon-72x72.svg',
      data: payload.data,
      vibrate: [100, 50, 100],
      requireInteraction: true,
      tag: payload.data?.order_number ? `order-${payload.data.order_number}` : 'kasi-bites',
    } as NotificationOptions & { vibrate?: number[] }

    event.waitUntil(
      self.registration.showNotification(payload.title, options)
    )
  } catch (error) {
    console.error('Error showing notification:', error)
  }
})

// Notification click event handler
self.addEventListener('notificationclick', (event) => {
  event.notification.close()

  const orderNumber = event.notification.data?.order_number

  // Determine the URL to open
  const urlToOpen = orderNumber
    ? `/order-tracking/${orderNumber}`
    : '/'

  event.waitUntil(
    self.clients.matchAll({ type: 'window', includeUncontrolled: true }).then((clientList) => {
      // Check if there's already a window open
      for (const client of clientList) {
        if ('focus' in client) {
          client.focus()
          // Navigate to the order tracking page if we have an order number
          if (orderNumber) {
            client.navigate(urlToOpen)
          }
          return
        }
      }
      // No window open, open a new one
      return self.clients.openWindow(urlToOpen)
    })
  )
})

// Push subscription change event handler (for re-subscribing if subscription expires)
self.addEventListener('pushsubscriptionchange', (event) => {
  const resubscribe = async () => {
    try {
      const subscription = await self.registration.pushManager.subscribe({
        userVisibleOnly: true,
        applicationServerKey: (event as any).oldSubscription?.options?.applicationServerKey,
      })

      // Send the new subscription to the server
      const response = await fetch('/api/web-push/subscribe', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          endpoint: subscription.endpoint,
          keys: {
            p256dh: btoa(String.fromCharCode(...new Uint8Array(subscription.getKey('p256dh')!))),
            auth: btoa(String.fromCharCode(...new Uint8Array(subscription.getKey('auth')!))),
          },
        }),
      })

      if (!response.ok) {
        throw new Error('Failed to re-subscribe')
      }
    } catch (error) {
      console.error('Failed to re-subscribe:', error)
    }
  }

  event.waitUntil(resubscribe())
})
